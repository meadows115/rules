tenets:
  - name:  initialize-using-composite-literal
    actions:
      codelingo/docs:
        title: Initialize instance using composite literal
        body: |
          Sometimes the zero value isn't good enough and an initializing constructor 
          is necessary. We can simplify the code using a composite literal, which is 
          an expression that creates a new instance each time it is evaluated.
          
          ## Bad code
          ```golang
          // NewFile is a function containing an initializing constructor. 
          func NewFile(fd int, name string) *File {
              if fd < 0 {
                  return nil
              }
              f := new(File)
              f.fd = fd
              f.name = name
              f.dirinfo = nil
              f.nepipe = 0
              return f
          }
          ```
          ## Good code
          ```golang
          // NewFile is a function that is an initalising constructor that has been simplified by using a composite literal.  
          func NewFile(fd int, name string) *File {
              if fd < 0 {
                  return nil
              }
              return &File{fd, name, nil, 0}
          }
          ```
      codelingo/review:
        comment: Initialize `{{varName}}` using a composite literal to simplify the code. [as specified in Effective Go](https://golang.org/doc/effective_go.html#composite_literals)
    query: |
      import codelingo/ast/go
      
      go.element(depth = any):
        go.assign_stmt:
          tok == ":="
          go.lhs:
            go.ident:
              name as varName
          go.rhs:
            go.call_expr:
              go.ident:
                name == "new"
        @review comment
        go.assign_stmt(depth=any):
          tok == "="
          go.lhs:
            go.selector_expr:
              go.ident:
                name == varName
